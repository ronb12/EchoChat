rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user owns the resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Users collection
    match /users/{userId} {
      // Allow users to read/write their own data
      allow read, write: if isOwner(userId);
      // Allow authenticated users to read public profiles
      allow read: if isAuthenticated() && 
        (resource.data.privacy == null || 
         resource.data.privacy.profileVisibility == 'public');
      // Allow authenticated users to read basic user info for presence/contacts/search
      allow read: if isAuthenticated();
      // Allow list queries for authenticated users (needed for search)
      allow list: if isAuthenticated();
    }
    
    // Profiles collection - for user profiles, aliases, status, etc.
    match /profiles/{userId} {
      // Allow authenticated users to read any profile (for displaying user info)
      allow read: if isAuthenticated();
      // Allow users to create their own profile
      allow create: if isAuthenticated() && isOwner(userId);
      // Allow users to update their own profile
      allow update: if isAuthenticated() && isOwner(userId);
      // Allow users to delete their own profile
      allow delete: if isAuthenticated() && isOwner(userId);
    }
    
    // Contacts collection - documents with userId and contactId fields
    match /contacts/{contactId} {
      // Allow list queries for authenticated users (will filter by userId in query)
      allow list: if isAuthenticated();
      // Allow read if the document's userId or contactId field matches the authenticated user
      allow get: if isAuthenticated() && 
        (resource.data.userId == request.auth.uid || 
         resource.data.contactId == request.auth.uid ||
         resource == null);
      // Allow create if userId matches authenticated user (own contact list)
      // OR if contactId matches authenticated user (reverse entry when accepting request)
      allow create: if isAuthenticated() && 
        (request.resource.data.userId == request.auth.uid ||
         request.resource.data.contactId == request.auth.uid);
      // Allow update/delete if userId matches authenticated user
      allow update, delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Contact requests collection
    match /contactRequests/{requestId} {
      // Helper function to check if user is sender or receiver (by UID or email)
      function isSenderOrReceiver() {
        let userEmail = request.auth.token.email;
        return isAuthenticated() && (
          // Check by UID (primary method)
          request.auth.uid == resource.data.fromUserId || 
          request.auth.uid == resource.data.toUserId ||
          // Fallback: Check by email (handles UID mismatches)
          (userEmail != null && (
            userEmail == resource.data.fromUserEmail ||
            userEmail == resource.data.toUserEmail
          ))
        );
      }
      
      // Allow list queries for authenticated users (needed for getPendingRequests)
      allow list: if isAuthenticated();
      // Allow read if user is sender or receiver (by UID or email)
      allow read: if isSenderOrReceiver();
      // Allow create if user is the sender
      allow create: if isAuthenticated() && 
        request.auth.uid == request.resource.data.fromUserId;
      // Allow update/delete if user is sender or receiver (by UID or email)
      allow update, delete: if isSenderOrReceiver();
    }
    
    // Chats collection
    match /chats/{chatId} {
      // Allow authenticated users to read chats they participate in
      allow read: if isAuthenticated() && 
        (resource.data.participants == null || request.auth.uid in resource.data.participants);
      // Allow creating chats if user is in participants list
      allow create: if isAuthenticated() && 
        request.resource.data.participants != null &&
        request.auth.uid in request.resource.data.participants;
      // Allow updating chats if user is a participant
      allow update: if isAuthenticated() && 
        request.auth.uid in resource.data.participants;
      // Allow deleting chats if user is a participant
      allow delete: if isAuthenticated() && 
        request.auth.uid in resource.data.participants;

      match /readPointers/{readerId} {
        function chatSnapshot() {
          return get(/databases/$(database)/documents/chats/$(chatId));
        }

        function isParticipant() {
          let chatSnap = chatSnapshot();
          return chatSnap.data != null &&
            chatSnap.data.participants != null &&
            request.auth.uid in chatSnap.data.participants;
        }

        allow read: if isAuthenticated() && isParticipant();
        allow create, update: if isAuthenticated() &&
          request.auth.uid == readerId &&
          isParticipant();
        allow delete: if false;
      }
    }
    
    // Messages collection
    match /messages/{messageId} {
      function chatDoc() {
        return get(/databases/$(database)/documents/chats/$(resource.data.chatId));
      }
      
      function isChatParticipant() {
        return isAuthenticated() &&
          chatDoc().data.participants != null &&
          request.auth.uid in chatDoc().data.participants;
      }
      
      function fieldUnchanged(field) {
        return request.resource.data[field] == resource.data[field];
      }
      
      function isServerTimestamp(value) {
        return value == request.time;
      }

      function isReadReceiptUpdate() {
        let readAtUnchangedOrSet = request.resource.data.readAt == resource.data.readAt ||
          (resource.data.readAt == null && isServerTimestamp(request.resource.data.readAt));

        return isChatParticipant() &&
          request.resource.data.chatId == resource.data.chatId &&
          request.resource.data.senderId == resource.data.senderId &&
          fieldUnchanged('text') &&
          fieldUnchanged('encryptedText') &&
          fieldUnchanged('isEncrypted') &&
          fieldUnchanged('senderName') &&
          fieldUnchanged('timestamp') &&
          fieldUnchanged('deliveredAt') &&
          fieldUnchanged('reactions') &&
          fieldUnchanged('edited') &&
          fieldUnchanged('editedAt') &&
          fieldUnchanged('deleted') &&
          fieldUnchanged('deletedAt') &&
          fieldUnchanged('deletedForEveryone') &&
          fieldUnchanged('sticker') &&
          fieldUnchanged('stickerId') &&
          fieldUnchanged('stickerPackId') &&
          fieldUnchanged('image') &&
          fieldUnchanged('audio') &&
          fieldUnchanged('file') &&
          fieldUnchanged('video') &&
          fieldUnchanged('videoName') &&
          fieldUnchanged('imageName') &&
          fieldUnchanged('audioName') &&
          fieldUnchanged('fileName') &&
          fieldUnchanged('fileSize') &&
          fieldUnchanged('fileType') &&
          readAtUnchangedOrSet;
      }
      
      // Allow read if user is authenticated (for public messages or participants)
      allow read: if isAuthenticated();
      // Allow create if user is authenticated
      allow create: if isAuthenticated() && 
        request.resource.data.senderId == request.auth.uid;
      // Allow update/delete if user is the sender
      allow update, delete: if isAuthenticated() && 
        (resource.data.senderId == request.auth.uid || isReadReceiptUpdate());

    }
    
    // Groups collection
    match /groups/{groupId} {
      allow read, write: if isAuthenticated() && 
        request.auth.uid in resource.data.members;
      allow create: if isAuthenticated() && 
        request.auth.uid in request.resource.data.members;
    }
    
    // Notifications collection
    match /notifications/{notificationId} {
      allow read, write: if isAuthenticated() && 
        request.auth.uid == resource.data.userId;
      allow create: if isAuthenticated() && 
        request.auth.uid == request.resource.data.userId;
    }
    
    // Settings collection
    match /settings/{userId} {
      allow read, write: if isOwner(userId);
    }
    
    // Blocked users collection - query structure: documents with userId field
    match /blocked/{blockedId} {
      // Allow list queries for authenticated users (will filter by userId in query)
      allow list: if isAuthenticated();
      // Allow read if the document's userId field matches the authenticated user
      allow get: if isAuthenticated() && 
        (resource.data.userId == request.auth.uid || 
         resource == null || 
         request.auth.uid == blockedId);
      // Allow write if userId matches authenticated user
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid;
      allow update, delete: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Reports collection
    match /reports/{reportId} {
      allow create: if isAuthenticated();
      allow read: if isAuthenticated() && 
        request.auth.token.admin == true;
    }
    
    // Payments/Transactions collection (for Stripe)
    match /payments/{paymentId} {
      allow read: if isAuthenticated() && 
        (request.auth.uid == resource.data.senderId || 
         request.auth.uid == resource.data.recipientId);
      allow create: if isAuthenticated() && 
        request.auth.uid == request.resource.data.senderId;
    }
    
    // Stripe accounts collection
    match /stripe_accounts/{userId} {
      allow read, write: if isOwner(userId);
    }

    // Call signaling sessions
    match /callSessions/{callId} {
      allow create: if isAuthenticated() &&
        request.resource.data.callerId == request.auth.uid &&
        request.resource.data.receiverId != null;

      function callSessionData() {
        return resource != null
          ? resource.data
          : get(/databases/$(database)/documents/callSessions/$(callId)).data;
      }

      function isCallParticipant() {
        let callData = callSessionData();
        return isAuthenticated() &&
          callData != null &&
          (callData.callerId == request.auth.uid ||
           callData.receiverId == request.auth.uid ||
           isAdmin());
      }

      allow read, update: if isCallParticipant();

      allow delete: if isCallParticipant();

      match /candidates/{candidateId} {
        allow create: if isAuthenticated() &&
          ((get(/databases/$(database)/documents/callSessions/$(callId)).data.callerId == request.auth.uid) ||
           (get(/databases/$(database)/documents/callSessions/$(callId)).data.receiverId == request.auth.uid));

        allow read: if isAuthenticated() &&
          ((get(/databases/$(database)/documents/callSessions/$(callId)).data.callerId == request.auth.uid) ||
           (get(/databases/$(database)/documents/callSessions/$(callId)).data.receiverId == request.auth.uid));

        allow delete: if isCallParticipant();
        allow update: if false;
      }
    }

    match /callHistory/{recordId} {
      allow create: if isAuthenticated() &&
        request.auth.uid == request.resource.data.callerId;

      allow get, update: if isAuthenticated() &&
        (resource.data.callerId == request.auth.uid ||
         resource.data.receiverId == request.auth.uid);

      allow list: if isAuthenticated() &&
        request.query.limit <= 100 &&
        request.query.where.size() == 1 &&
        request.query.where[0].field.fieldPath == 'participants' &&
        request.query.where[0].op == 'array_contains' &&
        request.query.where[0].value == request.auth.uid;

      allow delete: if false;
    }
    
    // Sticker packs collection
    match /stickerPacks/{packId} {
      allow read: if isAuthenticated();
      allow create, update, delete: if isAuthenticated() && 
        request.auth.token.admin == true;
    }
    
    // Sticker usage collection (for analytics)
    match /stickerUsage/{usageId} {
      allow read, write: if isAuthenticated();
    }
    
    // FCM tokens collection (for push notifications)
    match /fcmTokens/{userId} {
      allow read, write: if isOwner(userId);
    }
    
    // Polls collection
    match /polls/{pollId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
        request.resource.data.createdBy == request.auth.uid;
      allow update, delete: if isAuthenticated() && 
        resource.data.createdBy == request.auth.uid;
    }
    
    // Businesses collection
    match /businesses/{businessId} {
      allow read: if isAuthenticated();
      allow create, update, delete: if isAuthenticated() && 
        (resource == null || resource.data.ownerId == request.auth.uid);
    }
    
    // Organizations collection (enterprise)
    match /organizations/{orgId} {
      allow read: if isAuthenticated() && 
        request.auth.uid in resource.data.members;
      allow create: if isAuthenticated() && 
        request.auth.uid in request.resource.data.members;
      allow update, delete: if isAuthenticated() && 
        request.auth.uid == resource.data.ownerId;
    }
    
    // Audit logs collection (enterprise)
    match /auditLogs/{logId} {
      allow read: if isAuthenticated() && 
        request.auth.token.admin == true;
      allow create: if isAuthenticated();
    }
    
    // Communities collection
    match /communities/{communityId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
        request.auth.uid == request.resource.data.creatorId;
      allow update, delete: if isAuthenticated() && 
        request.auth.uid == resource.data.creatorId;
    }
    
    // Announcements collection
    match /announcements/{announcementId} {
      allow read: if isAuthenticated();
      allow create, update, delete: if isAuthenticated() && 
        (resource == null || resource.data.createdBy == request.auth.uid);
    }
    
    // Workspaces collection (collaboration)
    match /workspaces/{workspaceId} {
      allow read: if isAuthenticated() && 
        request.auth.uid in resource.data.members;
      allow create: if isAuthenticated() && 
        request.auth.uid in request.resource.data.members;
      allow update, delete: if isAuthenticated() && 
        request.auth.uid == resource.data.ownerId;
    }
    
    // Channels collection (collaboration)
    match /channels/{channelId} {
      allow read: if isAuthenticated() && 
        request.auth.uid in get(/databases/$(database)/documents/workspaces/$(resource.data.workspaceId)).data.members;
      allow create: if isAuthenticated();
      allow update, delete: if isAuthenticated() && 
        request.auth.uid == resource.data.createdBy;
    }
    
    // Tasks collection (collaboration)
    match /tasks/{taskId} {
      allow read: if isAuthenticated();
      allow create, update, delete: if isAuthenticated() && 
        (resource == null || resource.data.createdBy == request.auth.uid);
    }
    
    // Two-factor authentication codes
    match /twoFactorCodes/{userId} {
      allow read, write: if isOwner(userId);
    }
    
    // Typing indicators subcollection under chats
    match /chats/{chatId}/typing/{userId} {
      allow read: if isAuthenticated() && 
        request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
      allow write: if isAuthenticated() && 
        (request.auth.uid == userId || 
         request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants);
    }
    
    // Helper function to check if user is admin
    function isAdmin() {
      return isAuthenticated() && (
        request.auth.token.email == 'ronellbradley@bradleyvs.com' ||
        request.auth.token.admin == true ||
        (exists(/databases/$(database)/documents/users/$(request.auth.uid)) && 
         get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true)
      );
    }
    
    // Ratings Collection
    match /ratings/{ratingId} {
      // Allow users to create their own ratings
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid;
      // Allow users to read their own ratings
      allow read: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      // Allow admins to read all ratings
      allow read: if isAdmin();
      // Allow list queries for admins (to view all ratings)
      allow list: if isAdmin();
      // No update or delete (ratings are permanent)
    }
    
    // Feature Requests Collection
    match /featureRequests/{requestId} {
      // Allow users to create feature requests
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid;
      // Allow users to read their own feature requests
      allow read: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      // Allow admins to read all feature requests
      allow read: if isAdmin();
      // Allow list queries for authenticated users (to view their own requests)
      allow list: if isAuthenticated();
      // Allow list queries for admins (to view all requests)
      allow list: if isAdmin();
      // Allow users to update their own requests (e.g., add details)
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Support Tickets Collection
    match /supportTickets/{ticketId} {
      // Allow users to create support tickets
      allow create: if isAuthenticated() && 
        request.resource.data.userId == request.auth.uid;
      // Allow users to read their own tickets
      allow read: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
      // Allow admins to read all tickets
      allow read: if isAdmin();
      // Allow list queries for authenticated users (to view their own tickets)
      allow list: if isAuthenticated();
      // Allow list queries for admins (to view all tickets)
      allow list: if isAdmin();
      // Allow users to update their own tickets (e.g., add comments)
      allow update: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
  }
}
